<html>
<head>
<title>Examen</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" href="../styles.css" type="text/css">
</head>

<body>
<p class="pageTitle">Verdere optimalisatie</p>
<p><em>Voor het project <strong>volstaat</strong> in eerste instantie een <strong>correct</strong> 
  en redelijk effici&euml;nt algoritme dat aan de opdracht voldoet.</em> Eens 
  je dit af hebt, kan je nog eens nadenken over verdere optimalisaties, die het 
  algoritme effici&euml;nter kunnen maken. Je kiest zelf hoever je hierin gaat 
  binnen de tijd die beschikbaar is voor het project (20 uur). Op de evaluatie 
  zal een meer effici&euml;nt algoritme beter scoren dan een minder effici&euml;nt. 
  Je kan hierin erg ver gaan, maar dat is, gezien de beperkte tijd, niet de bedoeling.</p>
<p>Daar effici&euml;ntieverhogingen meestal een negatief effect hebben op de complexiteit 
  van het algoritme, wat het minder begrijpbaar en onderhoudbaar maakt, zullen 
  enkel werkelijke en significante effici&euml;ntieverhogingen positief worden 
  ge&euml;valueerd. Nodeloze complexiteit wordt negatief in rekening gebracht. 
  Je moet zelf in staat zijn de afweging tussen significant en zinloos te maken, 
  en deze keuze kunnen verdedigen.</p>
<h1>Criteria</h1>
<p>Effici&euml;ntie is een breed begrip. Vaak moet het ene voordeel tegen het 
  andere worden afgewogen. Hieronder volgen wat richtlijnen die zullen toegepast 
  worden bij de evaluatie:</p>
<ul>
  <li>Tijdseffici&euml;ntie gaat boven geheugeneffici&euml;ntie, binnen redelijke 
    grenzen.</li>
  <li>In de voorbeeldapplicatie is het bouwen van de grafe van logische circuits 
    iets wat enkel tijdens initialisatie gebeurt. Mutatis mutandis geldt hetzelfde 
    voor het afbreken. Het wijzigen van de booleaanse waarde van logische circuits 
    gebeurt relatief zeer vaak. De effici&euml;ntie van het herberekenen van de 
    waarden is dus belangrijker dan de effici&euml;ntie van de adminstratie van 
    de grafestructuur, binnen redelijke grenzen.<br>
    Als je de gegeven code bekijkt, zal het duidelijk worden dat ook het verwijderen 
    of toevoegen van inputs aan een <code>And</code> of een <code>Or</code>, of 
    het veranderen van de input van een <code>Not</code>, als gevolg heeft dat 
    de poorten die van die <code>And</code>, <code>Or</code> of <code>Not</code> 
    afhangen, geupdate moeten worden. Updates worden dus niet enkel door <code>Bit</code>s 
    ge&iuml;nitieerd. De performantie van deze updates is echter van veel minder 
    belang dan de performantie van de updates ge&iuml;nitieerd door een <code>Bit</code>, 
    binnen redelijk grenzen.</li>
</ul>
<h1>Optimalisatie-idee&euml;n</h1>
<p>Hieronder staan enkele idee&euml;n voor verdere optimalisatie, maar er is niet 
  gegarandeerd dat deze idee&euml;n tot zinvolle resultaten leiden. Misschien 
  heb je zelf betere idee&euml;n.</p>
<ul>
  <li>Wanneer je enkel de deelgrafe van logische poorten die afhangt van de bit 
    die flipt beschouwt in het algoritme, dan is er exact 1 logisch circuit met 
    initi&euml;le indegrees 0: de bit zelf. Alle afhankelijk logische poorten 
    hebben een indegrees &gt; 0.</li>
  <li>De bit zelf moet niet gewaarschuwd worden.</li>
  <li>Er zullen exact 9 elementen in de FIFO structuur geplaatst worden door het 
    klassieke algoritme wanneer het op het voorbeeld wordt losgelaten.</li>
  <li>Op het einde van het algoritme zijn alle indegrees == 0.</li>
  <li>Misschien kunnen delen van het algoritme verhuizen naar de methodes die 
    de grafe opbouwen en afbreken.</li>
  <li>In de demo veranderen <kbd>o1</kbd> en <kbd>a1</kbd> nooit van waarde. <kbd>o2</kbd> 
    hangt enkel van <kbd>o1</kbd> en <kbd>a1</kbd> af, en zal dus ook nooit veranderen. 
    Eventuele latere poorten die enkel van <kbd>o2</kbd> afhangen in de deelgrafe 
    die vertrekt uit <kbd>bit1</kbd> zullen dus ook nooit veranderen. Dit zijn 
    er potenti&euml;el heel veel. Te weten komen dat <kbd>o1</kbd> en <kbd>a1</kbd> 
    nooit van waarde veranderen vereist statische analyse van de booleaanse logica, 
    en dat gaat veel te ver. Dat <kbd>o2</kbd> en verdere afhankelijke poorten 
    niet veranderen zou echter dynamisch bepaald kunnen worden: de enige inputs 
    van <kbd>o2</kbd> zijn <kbd>o1</kbd> en <kbd>a1</kbd> en als die blijken niet 
    te veranderen tijdens het algoritme, hoeven we <kbd>o2</kbd> en verdere afhankelijken 
    niet meer te bezoeken.</li>
</ul>
</body>
</html>
